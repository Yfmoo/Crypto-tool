# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'c:\LearnPyhon\pythonPractice\Python_class\final_homework\Gu_dian.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
import numpy as np
import string

class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(996, 613)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(Form)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.treeWidget = QtWidgets.QTreeWidget(Form)
        self.treeWidget.setObjectName("treeWidget")
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        item_0 = QtWidgets.QTreeWidgetItem(self.treeWidget)
        self.horizontalLayout.addWidget(self.treeWidget)
        self.plainTextEdit_3 = QtWidgets.QPlainTextEdit(Form)
        self.plainTextEdit_3.setStyleSheet("background-color: rgb(255, 255, 255);\n"
"color: rgb(0, 0, 0);\n"
"border-color: rgb(0, 170, 255);\n"
"gridline-color: rgb(0, 170, 255);\n"
"border-top-color: rgb(0, 170, 255);")
        self.plainTextEdit_3.setFrameShape(QtWidgets.QFrame.Box)
        self.plainTextEdit_3.setLineWidth(2)
        self.plainTextEdit_3.setMidLineWidth(0)
        self.plainTextEdit_3.setBackgroundVisible(False)
        self.plainTextEdit_3.setObjectName("plainTextEdit_3")
        self.plainTextEdit_3.setPlaceholderText("请输入密文")
        self.horizontalLayout.addWidget(self.plainTextEdit_3)
        self.verticalLayout_2 = QtWidgets.QVBoxLayout()
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.pushButton_3 = QtWidgets.QPushButton(Form)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton_3.setFont(font)
        self.pushButton_3.setStyleSheet("color: rgb(255, 0, 0);\n"
"background-color: rgb(0, 170, 255);")
        self.pushButton_3.setObjectName("pushButton_3")
        self.verticalLayout_2.addWidget(self.pushButton_3)
        self.pushButton_4 = QtWidgets.QPushButton(Form)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.pushButton_4.setFont(font)
        self.pushButton_4.setStyleSheet("background-color: rgb(0, 170, 255);\n"
"color: rgb(255, 0, 0);")
        self.pushButton_4.setObjectName("pushButton_4")
        self.verticalLayout_2.addWidget(self.pushButton_4)
        self.lineEdit_2 = QtWidgets.QLineEdit(Form)
        font = QtGui.QFont()
        font.setPointSize(11)
        self.lineEdit_2.setFont(font)
        self.lineEdit_2.setStyleSheet("color: rgb(255, 0, 0);")
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.lineEdit_2.setPlaceholderText("key")
        self.verticalLayout_2.addWidget(self.lineEdit_2)
        self.horizontalLayout.addLayout(self.verticalLayout_2)
        self.plainTextEdit_4 = QtWidgets.QPlainTextEdit(Form)
        self.plainTextEdit_4.setStyleSheet("background-color: rgb(255, 255, 255);\n"
"color: rgb(0, 0, 0);")
        self.plainTextEdit_4.setFrameShape(QtWidgets.QFrame.Box)
        self.plainTextEdit_4.setLineWidth(2)
        self.plainTextEdit_4.setObjectName("plainTextEdit_4")
        self.plainTextEdit_4.setPlaceholderText("请输入明文")
        self.horizontalLayout.addWidget(self.plainTextEdit_4)
        self.horizontalLayout.setStretch(0, 1)
        self.horizontalLayout.setStretch(1, 3)
        self.horizontalLayout.setStretch(2, 1)
        self.horizontalLayout.setStretch(3, 3)
        self.horizontalLayout_2.addLayout(self.horizontalLayout)

        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)
        
        
        # 连接按钮到它们的处理函数
        self.pushButton_3.clicked.connect(self.encrypt)
        self.pushButton_4.clicked.connect(self.decrypt)
        
        # 连接 tree widget 选项变化到处理函数
        self.treeWidget.itemSelectionChanged.connect(self.handleSelectionChanged)

        # 存储每种加密类型的结果状态
        self.encryption_results = {
            "Caser": {"encrypted": "", "decrypted": "", "key": ""},
            "Veginere": {"encrypted": "", "decrypted": "", "key": ""},
            "Atbash": {"encrypted": "", "decrypted": "", "key": ""},
            "Hill": {"encrypted": "", "decrypted": "", "key": ""},
            "Affine": {"encrypted": "", "decrypted": "", "key": ""},
            "Scytale": {"encrypted": "", "decrypted": "", "key": ""},
            "Polybius square": {"encrypted": "", "decrypted": "", "key": ""},
            "ADFGVX": {"encrypted": "", "decrypted": "", "key": ""},
            "Bacon": {"encrypted": "", "decrypted": "", "key": ""},
            "Four-square": {"encrypted": "", "decrypted": "", "key": ""},
            "Playfair": {"encrypted": "", "decrypted": "", "key": ""},
            "Mose": {"encrypted": "", "decrypted": "", "key": ""},
            "Beaufort": {"encrypted": "", "decrypted": "", "key": ""},
            "Trifid": {"encrypted": "", "decrypted": "", "key": ""},
            "Two-square": {"encrypted": "", "decrypted": "", "key": ""},
            "Vernam": {"encrypted": "", "decrypted": "", "key": ""},
        }
        
        #Atbash映射字母表
        self.normal_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        self.reversed_alphabet = "ZYXWVUTSRQPONMLKJIHGFEDCBA"
    
    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.treeWidget.headerItem().setText(0, _translate("Form", "古典加密"))
        __sortingEnabled = self.treeWidget.isSortingEnabled()
        self.treeWidget.setSortingEnabled(False)
        self.treeWidget.topLevelItem(0).setText(0, _translate("Form", "Caser"))
        self.treeWidget.topLevelItem(1).setText(0, _translate("Form", "Veginere"))
        self.treeWidget.topLevelItem(2).setText(0, _translate("Form", "Atbash"))
        self.treeWidget.topLevelItem(3).setText(0, _translate("Form", "Hill"))
        self.treeWidget.topLevelItem(4).setText(0, _translate("Form", "Affine"))
        self.treeWidget.topLevelItem(5).setText(0, _translate("Form", "Scytale"))
        self.treeWidget.topLevelItem(6).setText(0, _translate("Form", "Polybius square"))
        self.treeWidget.topLevelItem(7).setText(0, _translate("Form", "ADFGVX"))
        self.treeWidget.topLevelItem(8).setText(0, _translate("Form", "Bacon"))
        self.treeWidget.topLevelItem(9).setText(0, _translate("Form", "Four-square"))
        self.treeWidget.topLevelItem(10).setText(0, _translate("Form", "Playfair"))
        self.treeWidget.topLevelItem(11).setText(0, _translate("Form", "Mose"))
        self.treeWidget.topLevelItem(12).setText(0, _translate("Form", "Beaufort"))
        self.treeWidget.topLevelItem(13).setText(0, _translate("Form", "Trifid"))
        self.treeWidget.topLevelItem(14).setText(0, _translate("Form", "Two-square"))
        self.treeWidget.topLevelItem(15).setText(0, _translate("Form", "Vernam"))
        self.treeWidget.setSortingEnabled(__sortingEnabled)
        self.pushButton_3.setText(_translate("Form", "加密"))
        self.pushButton_4.setText(_translate("Form", "解密"))

    #treeWidget选择情况处理
    def handleSelectionChanged(self):
        selected_items = self.treeWidget.selectedItems()
        if not selected_items:
            return
            
        selected_item_text = selected_items[0].text(0)
        if selected_item_text == "Affine":
            self.lineEdit_2.setPlaceholderText("（偏移量用逗号隔开）")  
        self.loadResults(selected_item_text)
    #加载加解密解果
    def loadResults(self, encryption_type):
        # 加载特定加密类型的结果
        if encryption_type in self.encryption_results:
            self.plainTextEdit_3.setPlainText(self.encryption_results[encryption_type]["encrypted"])
            self.plainTextEdit_4.setPlainText(self.encryption_results[encryption_type]["decrypted"])
            self.lineEdit_2.setText(self.encryption_results[encryption_type]["key"])  # 加载密钥
    #保存加解密结果
    def saveResults(self, encryption_type):
        # 保存特定加密类型的结果
        if encryption_type in self.encryption_results:
            self.encryption_results[encryption_type]["encrypted"] = self.plainTextEdit_3.toPlainText()
            self.encryption_results[encryption_type]["decrypted"] = self.plainTextEdit_4.toPlainText()
            self.encryption_results[encryption_type]["key"] = self.lineEdit_2.text()  # 保存密钥

    # 加密
    def encrypt(self):
        selected_items = self.treeWidget.selectedItems()
        if not selected_items:
            return
        
        selected_item_text = selected_items[0].text(0)
        plain_text = self.plainTextEdit_4.toPlainText()
        key = self.lineEdit_2.text()

        if selected_item_text == "Caser":
            try:
                key = int(key)
                encrypted_text = self.caesar_cipher_encrypt(plain_text, key)
                self.plainTextEdit_3.setPlainText(encrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_3.setPlainText("密钥无效，请输入一个数字。")
        elif selected_item_text == "Veginere":
            encrypted_text = self.vigenere_encrypt(plain_text, key)
            self.plainTextEdit_3.setPlainText(encrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Mose":
            encrypted_text = self.morse_encrypt(plain_text)
            self.plainTextEdit_3.setPlainText(encrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Atbash":
            encrypted_text = self.encrypt_atbash(plain_text)
            self.plainTextEdit_3.setPlainText(encrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Playfair":
            encrypted_text = self.encrypt_playfair(plain_text)
            self.plainTextEdit_3.setPlainText(encrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Hill":
            try:
                encrypted_text = self.encrypt_hill(plain_text)
                self.plainTextEdit_3.setPlainText(encrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_3.setPlainText("密钥无效！")
        elif selected_item_text == "Affine":
            try:
                encrypted_text = self.encrypt_affine(plain_text)
                self.plainTextEdit_3.setPlainText(encrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_3.setPlainText("密钥无效！")
        elif selected_item_text == "Scytale":
            try:
                encrypted_text = self.encrypt_scytale(plain_text)
                self.plainTextEdit_3.setPlainText(encrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_3.setPlainText("密钥无效！")
        elif selected_item_text == "Polybius square":
                encrypted_text = self.encrypt_polybius(plain_text)
                self.plainTextEdit_3.setPlainText(encrypted_text)
                self.saveResults(selected_item_text)
            
        # 可以在这里添加其他加密算法

    # 解密
    def decrypt(self):
        selected_items = self.treeWidget.selectedItems()
        if not selected_items:
            return
        
        selected_item_text = selected_items[0].text(0)
        encrypted_text = self.plainTextEdit_3.toPlainText()
        key = self.lineEdit_2.text()

        if selected_item_text == "Caser":
            try:
                key = int(key)
                decrypted_text = self.caesar_cipher_decrypt(encrypted_text, key)
                self.plainTextEdit_4.setPlainText(decrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_4.setPlainText("密钥无效，请输入一个数字。")
        elif selected_item_text == "Veginere":
            decrypted_text = self.vigenere_decrypt(encrypted_text, key)
            self.plainTextEdit_4.setPlainText(decrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Mose":
            decrypted_text = self.morse_decrypt(encrypted_text)
            self.plainTextEdit_4.setPlainText(decrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Atbash":
            decrypted_text = self.decrypt_atbash(encrypted_text)
            self.plainTextEdit_4.setPlainText(decrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Playfair":
            decrypted_text = self.decrypt_playfair(encrypted_text)
            self.plainTextEdit_4.setPlainText(decrypted_text)
            self.saveResults(selected_item_text)
        elif selected_item_text == "Hill":
            try:
                decrypted_text = self.decrypt_hill(encrypted_text)
                self.plainTextEdit_4.setPlainText(decrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_4.setPlainText("密钥无效！")
        elif selected_item_text == "Affine":
            try:
                decrypted_text = self.decrypt_affine(encrypted_text)
                self.plainTextEdit_4.setPlainText(decrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_4.setPlainText("密钥无效！")
        elif selected_item_text == "Scytale":
            try:
                decrypted_text = self.decrypt_scytale(encrypted_text)
                self.plainTextEdit_4.setPlainText(decrypted_text)
                self.saveResults(selected_item_text)
            except ValueError:
                self.plainTextEdit_4.setPlainText("密钥无效！")
        elif selected_item_text == "Polybius square":
            decrypted_text = self.decrypt_polybius(encrypted_text)
            self.plainTextEdit_4.setPlainText(decrypted_text)
            self.saveResults(selected_item_text)

        # 可以在这里添加其他解密算法

    """凯撒密码加解密"""
    # 凯撒加密算法
    def caesar_cipher_encrypt(self, text, shift):
        result = ""
        for i in range(len(text)):
            char = text[i]
            # 加密大写字符
            if char.isupper():
                result += chr((ord(char) + shift - 65) % 26 + 65)
            # 加密小写字符
            elif char.islower():
                result += chr((ord(char) + shift - 97) % 26 + 97)
            else:
                result += char  # 非字母字符直接添加
        return result
    # 凯撒解密算法
    def caesar_cipher_decrypt(self, text, shift):
        return self.caesar_cipher_encrypt(text, -shift)
    
    """维吉尼亚密码加解密"""
    # 维吉尼亚加密
    def vigenere_encrypt(self, plaintext, key):
        if not key:
            return "密钥不能为空。"

        def generate_key(text, key):
            key = list(key)
            if len(text) == len(key):
                return key
            else:
                for i in range(len(text) - len(key)):
                    key.append(key[i % len(key)])
            return ''.join(key)

        key = generate_key(plaintext, key)
        ciphertext = []

        for i in range(len(plaintext)):
            if plaintext[i].isalpha():
                shift = ord(key[i].upper()) - 65
                if plaintext[i].isupper():
                    encrypted_char = chr((ord(plaintext[i]) + shift - 65) % 26 + 65)
                else:
                    encrypted_char = chr((ord(plaintext[i]) + shift - 97) % 26 + 97)
                ciphertext.append(encrypted_char)
            else:
                ciphertext.append(plaintext[i])

        return ''.join(ciphertext)
    # 维吉尼亚解密
    def vigenere_decrypt(self, ciphertext, key):
        if not key:
            return "密钥不能为空。"

        def generate_key(text, key):
            key = list(key)
            if len(text) == len(key):
                return key
            else:
                for i in range(len(text) - len(key)):
                    key.append(key[i % len(key)])
            return ''.join(key)

        key = generate_key(ciphertext, key)
        plaintext = []

        for i in range(len(ciphertext)):
            if ciphertext[i].isalpha():
                shift = ord(key[i].upper()) - 65
                if ciphertext[i].isupper():
                    decrypted_char = chr((ord(ciphertext[i]) - shift - 65) % 26 + 65)
                else:
                    decrypted_char = chr((ord(ciphertext[i]) - shift - 97) % 26 + 97)
                plaintext.append(decrypted_char)
            else:
                plaintext.append(ciphertext[i])

        return ''.join(plaintext)

    """mose密码加解密"""
    # 摩斯密码字典
    morse_code_dict = {
        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.',
        'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.',
        'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-',
        'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',
        '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....',
        '7': '--...', '8': '---..', '9': '----.', '0': '-----', ', ': '--..--', '.': '.-.-.-',
        '?': '..--..', '/': '-..-.', '-': '-....-', '(': '-.--.', ')': '-.--.-'
    }
    # 摩斯加密算法
    def morse_encrypt(self, text):
        encrypted_text = ""
        for char in text.upper():
            if char != " ":
                encrypted_text += self.morse_code_dict.get(char, char) + " "
            else:
                encrypted_text += "/ "  # 用 / 表示单词间的空格
        return encrypted_text.strip()
    # 摩斯解密
    def morse_decrypt(self, morse_text):
        morse_text += " "
        decipher = ""
        citext = ""
        for letter in morse_text:
            if letter != " ":
                i = 0
                citext += letter
            else:
                i += 1
                if i == 2:
                    decipher += " "
                else:
                    decipher += list(self.morse_code_dict.keys())[list(self.morse_code_dict.values()).index(citext)]
                    citext = ""
        return decipher
     
    """Atbash加解密"""      
    #Atbash（埃特巴什）加密
    def encrypt_atbash(self, plaintext):
        encrypted_text = []
        for char in plaintext:
            if char.upper() in self.normal_alphabet:
                index = self.normal_alphabet.index(char.upper())
                encrypted_char = self.reversed_alphabet[index]
                if char.islower():
                    encrypted_char = encrypted_char.lower()
                encrypted_text.append(encrypted_char)
            else:
                encrypted_text.append(char)  # Keep non-alphabetic characters unchanged
        return ''.join(encrypted_text)
    #Atbash（埃特巴什）解密
    def decrypt_atbash(self, ciphertext):
        decrypted_text = []
        for char in ciphertext:
            if char.upper() in self.reversed_alphabet:
                index = self.reversed_alphabet.index(char.upper())
                decrypted_char = self.normal_alphabet[index]
                if char.islower():
                    decrypted_char = decrypted_char.lower()
                decrypted_text.append(decrypted_char)
            else:
                decrypted_text.append(char)  # Keep non-alphabetic characters unchanged
        return ''.join(decrypted_text)
    
    """栅栏加解密"""
    #栅栏加密
    def encrypt_playfair(self, plaintext):
        try:
            num_rails = int(self.lineEdit_2.text())
        except ValueError:
            self.lineEdit_2.setText("2")
            num_rails = int(self.lineEdit_2.text())  # 如果没有输入偏移值，则使用默认值2
        
        # 创建一个包含每个栏的空字符串列表
        rails = ['' for _ in range(num_rails)]
        
        # 从第一个栏开始，方向向下
        rail = 0
        direction = 1

        # 将字符放入栏中
        for char in plaintext:
            rails[rail] += char
            rail += direction

            # 当到达顶部或底部栏时，改变方向
            if rail == 0 or rail == num_rails - 1:
                direction *= -1

        # 连接所有栏以获得密文
        return ''.join(rails)
    #栅栏解密
    def decrypt_playfair(self, ciphertext):
        try:
            num_rails = int(self.lineEdit_2.text())
        except ValueError:
            self.lineEdit_2.setText("2")
            num_rails = int(self.lineEdit_2.text())  # 如果没有输入偏移值，则使用默认值2
        
        # 确定密文中每个栏的长度
        rail_lengths = [0] * num_rails
        rail = 0
        direction = 1

        for char in ciphertext:
            rail_lengths[rail] += 1
            rail += direction
            if rail == 0 or rail == num_rails - 1:
                direction *= -1

        # 使用密文中的字符重建栏
        rails = []
        idx = 0
        for length in rail_lengths:
            rails.append(ciphertext[idx:idx + length])
            idx += length

        # 通过以锯齿形顺序读取字符来重建明文
        plaintext = ''
        rail = 0
        direction = 1
        rail_indices = [0] * num_rails
        for _ in range(len(ciphertext)):
            plaintext += rails[rail][rail_indices[rail]]
            rail_indices[rail] += 1
            rail += direction
            if rail == 0 or rail == num_rails - 1:
                direction *= -1

        return plaintext
    
    """Hill加解密"""
    #密钥转矩阵
    def process_key(self):
        # 将密钥字符串转换为矩阵
        key = self.lineEdit_2.text().upper().replace(' ', '')
        size = int(len(key) ** 0.5)
        if size * size != len(key):
            raise ValueError("Key length must be a perfect square")
        
        key_matrix = []
        for i in range(size):
            row = [ord(key[size * i + j]) - ord('A') for j in range(size)]
            key_matrix.append(row)
        
        return np.array(key_matrix)
    # 密钥矩阵的模逆
    def mod_inverse(self, matrix, modulus):
        # 计算矩阵的模逆
        det = int(np.round(np.linalg.det(matrix))) % modulus
        if np.gcd(det, modulus) != 1:
            raise ValueError(f"Determinant {det} has no inverse under modulus {modulus}")
            return ""
        det_inv = pow(det, -1, modulus)
        matrix_modulus_inv = det_inv * np.round(det * np.linalg.inv(matrix)).astype(int) % modulus
        return matrix_modulus_inv
    # Hill加密
    def encrypt_hill(self, plaintext):
        plaintext = plaintext.upper().replace(' ', '')
        key_matrix = self.process_key()
        modulus = 26
        size = key_matrix.shape[0]
        padding_length = (size - len(plaintext) % size) % size
        plaintext += 'X' * padding_length  # 填充X以使明文长度是矩阵大小的倍数

        ciphertext = ''
        for i in range(0, len(plaintext), size):
            block = [ord(char) - ord('A') for char in plaintext[i:i+size]]
            encrypted_block = np.dot(key_matrix, block) % modulus
            ciphertext += ''.join(chr(num + ord('A')) for num in encrypted_block)

        return ciphertext
    # Hill解密
    def decrypt_hill(self, ciphertext):
        key_matrix = self.process_key()
        modulus = 26
        size = key_matrix.shape[0]
        
        try:
            inverse_key = self.mod_inverse(key_matrix, modulus)
        except ValueError as e:
            error = self.plainTextEdit_4.setPlainText(f"Error: {e}")
            return error

        plaintext = ''
        for i in range(0, len(ciphertext), size):
            block = [ord(char) - ord('A') for char in ciphertext[i:i+size]]
            decrypted_block = np.dot(inverse_key, block) % modulus
            plaintext += ''.join(chr(num + ord('A')) for num in decrypted_block)

        return plaintext.rstrip('X')  # 移除填充的X
    
    """Affine加解密"""
    #对输入的密钥进行处理
    def parse_key(self):
        self.m = 26
        key = self.lineEdit_2.text().split(',')
        if len(key) != 2:
            raise ValueError("Key must be in the format 'a,b'")
        self.a = int(key[0])
        self.b = int(key[1])
        if np.gcd(self.a, self.m) != 1:
            raise ValueError("Key 'a' must be coprime with 26")
    #Affine加密
    def encrypt_affine(self, plaintext):
        self.parse_key()
        ciphertext = []
        for char in plaintext.upper():
            if char in string.ascii_uppercase:
                x = ord(char) - ord('A')
                encrypted_char = chr((self.a * x + self.b) % self.m + ord('A'))
                ciphertext.append(encrypted_char)
            else:
                ciphertext.append(char)
        return ''.join(ciphertext)
    #Affine解密
    def decrypt_affine(self, ciphertext):
        self.parse_key()
        plaintext = []
        a_inv = self.find_inverse(self.a, self.m)
        for char in ciphertext.upper():
            if char in string.ascii_uppercase:
                y = ord(char) - ord('A')
                decrypted_char = chr((a_inv * (y - self.b)) % self.m + ord('A'))
                plaintext.append(decrypted_char)
            else:
                plaintext.append(char)
        return ''.join(plaintext)
    #找到a在模m下的逆元
    def find_inverse(self, a, m):
        for x in range(1, m):
            if (a * x) % m == 1:
                return x
        raise ValueError(f"No inverse exists for a={a} and m={m}")
    
    """Scytale加解密"""
    #加密
    def encrypt_scytale(self, plaintext):
        # 去掉所有空格
        key = int(self.lineEdit_2.text())
        plaintext = plaintext.replace(" ", "")
        # 计算行数
        num_rows = (len(plaintext) + key - 1) // key
        ciphertext = [''] * key

        for i in range(len(plaintext)):
            row = i % key
            ciphertext[row] += plaintext[i]

        return ''.join(ciphertext)
    #解密
    def decrypt_scytale(self, ciphertext):
        key = int(self.lineEdit_2.text())
        num_rows = (len(ciphertext) + key - 1) // key
        plaintext = [''] * num_rows

        index = 0
        for col in range(key):
            for row in range(num_rows):
                if index < len(ciphertext):
                    plaintext[row] += ciphertext[index]
                    index += 1

        return ''.join(plaintext)
    
    """Polybius square加解密"""
    def encrypt_polybius(self, plaintext):
        self.square = [
            ['A', 'B', 'C', 'D', 'E'],
            ['F', 'G', 'H', 'I', 'K'],
            ['L', 'M', 'N', 'O', 'P'],
            ['Q', 'R', 'S', 'T', 'U'],
            ['V', 'W', 'X', 'Y', 'Z']
        ]
        self.char_to_coords = {self.square[row][col]: (row + 1, col + 1) for row in range(5) for col in range(5)}
        self.coords_to_char = {(row + 1, col + 1): self.square[row][col] for row in range(5) for col in range(5)}
        ciphertext = []
        plaintext = plaintext.replace('J', 'I')  # 将 'J' 替换为 'I'
        for char in plaintext:
            if char.upper() in self.char_to_coords:  # 使用大写字母进行加密映射
                row, col = self.char_to_coords[char.upper()]
                ciphertext.append(f"{row}{col}")
            else:
                ciphertext.append(char)  # 保留非字母字符
        return ''.join(ciphertext)

    def decrypt_polybius(self, ciphertext):
        plaintext = []
        i = 0
        while i < len(ciphertext):
            if ciphertext[i].isdigit() and (i + 1) < len(ciphertext) and ciphertext[i + 1].isdigit():
                row = int(ciphertext[i])
                col = int(ciphertext[i + 1])
                char = self.coords_to_char[(row, col)]
                plaintext.append(char.lower() if ciphertext[i].islower() else char)  # 根据密文中的大小写信息保持解密后的大小写形式
                i += 2
            else:
                plaintext.append(ciphertext[i])
                i += 1
        return ''.join(plaintext)
